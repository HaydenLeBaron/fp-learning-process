I"ä<p>Haskell Functor signature: <code class="language-plaintext highlighter-rouge">Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</code></p>

<p>Where <code class="language-plaintext highlighter-rouge">f</code> is a Functor, <code class="language-plaintext highlighter-rouge">(a -&gt; b)</code> is a function that transforms <code class="language-plaintext highlighter-rouge">a</code> to <code class="language-plaintext highlighter-rouge">b</code>, and takes an <code class="language-plaintext highlighter-rouge">f a</code> (Functor of type <code class="language-plaintext highlighter-rouge">a</code>) and returns an <code class="language-plaintext highlighter-rouge">f b</code> (Functor of <code class="language-plaintext highlighter-rouge">b</code>).</p>

<hr />
<h2 id="example-option">Example (Option)</h2>

<p>This is an example of a functor called <code class="language-plaintext highlighter-rouge">Option</code>, youâ€™ll also hear it referred to as the <code class="language-plaintext highlighter-rouge">maybe</code> data type. <code class="language-plaintext highlighter-rouge">Option</code> is an <a class="internal-link" href="/algebraic-data-type"> Algebraic Data Type or ADT</a>, specifically it is a <a class="internal-link" href="/sum-type">Sum Type</a>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Option(a) =
	| Some(a)
	| None

let map: (a =&gt; b) =&gt; Option(a) =&gt; Option(b) = f =&gt;
	fun
	| Some(a) =&gt; Some(f(a))
	| None =&gt; None

// Constructor usage
let a = Some(1);
let b = None;

// Functor has one function: `map`
let c = Option.map(x =&gt; x + 1, Some(1));
// output: Some(2)

let d = Option.map(x =&gt; x + 2, None)
// output: None
</code></pre></div></div>

:ET